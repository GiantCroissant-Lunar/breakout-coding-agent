name: RFC Health Monitor
on:
  schedule:
    # Run every 5 minutes for testing, then change back to 30 minutes
    - cron: '*/5 * * * *'
  
  workflow_dispatch:
    inputs:
      force_interventions:
        description: 'Force interventions even if not meeting time thresholds'
        required: false
        default: 'false'

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  monitor:
    runs-on: ubuntu-latest
    
    steps:
    - name: Get GitHub App token
      id: app-token
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ secrets.APP_ID }}
        private-key: ${{ secrets.APP_PRIVATE_KEY }}
        
    - name: Check out code
      uses: actions/checkout@v4
      
    - name: Preflight gh environment
      run: |
        set -euo pipefail
        echo "Repo: $GITHUB_REPOSITORY"
        gh --version
        gh auth status || true
      env:
        GH_TOKEN: ${{ steps.app-token.outputs.token }}

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Run RFC Health Monitor
      run: |
        python3 << 'EOF'
        import json
        import subprocess
        import datetime
        import os
        from typing import Dict, List, Optional

        class RFCHealthMonitor:
            def __init__(self):
                self.repo = "${{ github.repository }}"
                self.force_interventions = "${{ github.event.inputs.force_interventions }}" == "true"
                self.interventions_taken = []
                
            def run_gh(self, cmd: str, *, required: bool = False) -> str:
                """Execute GitHub CLI command; fail loudly when required"""
                try:
                    result = subprocess.run(
                        f"gh {cmd}", shell=True, capture_output=True, text=True, check=True
                    )
                    out = result.stdout.strip()
                    if required and not out:
                        print(f"Error: gh {cmd} returned empty output")
                        raise SystemExit(1)
                    return out
                except subprocess.CalledProcessError as e:
                    print(f"Error running gh {cmd}: {e.stderr}")
                    if required:
                        raise SystemExit(1)
                    return ""
            
            def get_time_diff_hours(self, timestamp: str) -> float:
                """Calculate hours since timestamp"""
                try:
                    dt = datetime.datetime.fromisoformat(timestamp.replace('Z', '+00:00'))
                    now = datetime.datetime.now(datetime.timezone.utc)
                    return (now - dt).total_seconds() / 3600
                except:
                    return 0
            
            def check_stalled_prs(self) -> List[Dict]:
                """Check for stalled PRs from GitHub Coding Agent"""
                print("üîç Checking for stalled PRs...")
                
                try:
                    prs_a = self.run_gh(
                        f'pr list --repo "{self.repo}" --author="app/copilot-swe-agent" --json number,title,updatedAt,isDraft,headRefName'
                    ) or '[]'
                    prs_b = self.run_gh(
                        f'pr list --repo "{self.repo}" --author="Copilot" --json number,title,updatedAt,isDraft,headRefName'
                    ) or '[]'
                    merged = {p['number']: p for p in (json.loads(prs_a) + json.loads(prs_b))}
                    prs = list(merged.values())
                    
                    stalled_prs = []
                    for pr in prs:
                        hours_since_update = self.get_time_diff_hours(pr['updatedAt'])
                        
                        # Consider stalled if >2 hours without update (or force mode)
                        is_stalled = hours_since_update > 2 or self.force_interventions
                        
                        status = "üü¢ Active" if hours_since_update < 1 else \
                                "üü° Slowing" if hours_since_update < 2 else \
                                "üî¥ STALLED"
                        
                        print(f"  PR #{pr['number']}: {pr['title'][:50]}...")
                        print(f"    Last update: {hours_since_update:.1f}h ago ({status})")
                        
                        if is_stalled:
                            stalled_prs.append({
                                **pr,
                                'hours_stalled': hours_since_update
                            })
                    
                    return stalled_prs
                    
                except Exception as e:
                    print(f"Error checking PRs: {e}")
                    return []
            
            def check_abandoned_issues(self) -> List[Dict]:
                """Check for issues assigned >30 minutes without PR"""
                print("üîç Checking for abandoned issues...")
                
                try:
                    # Use broader query then filter - gh CLI --assignee has issues with bot accounts
                    issues_json = self.run_gh(
                        f'issue list --repo "{self.repo}" --state=open --label=game-rfc --json number,title,assignees,createdAt',
                        required=True
                    )
                    issues = json.loads(issues_json) if issues_json else []
                    
                    abandoned_issues = []
                    for issue in issues:
                        # Filter for Copilot-assigned issues
                        assignee_logins = [assignee.get('login', '') for assignee in issue.get('assignees', [])]
                        if 'Copilot' not in assignee_logins:
                            continue
                            
                        hours_since_assigned = self.get_time_diff_hours(issue['createdAt'])
                        
                        # Check if there's a PR for this issue
                        issue_num = issue['number']
                          prs_json = self.run_gh(
                              f'pr list --repo "{self.repo}" --search "Fixes #{issue_num}" --json number'
                          )
                        has_pr = len(json.loads(prs_json) if prs_json else []) > 0
                        
                        # Consider abandoned if >24 hours assigned without PR (or force mode)
                        is_abandoned = (hours_since_assigned > 0.5 and not has_pr) or self.force_interventions
                        
                        status = "üü¢ Active" if has_pr else \
                                "üü° Recent" if hours_since_assigned < 8 else \
                                "üü† Delayed" if hours_since_assigned < 0.5 else \
                                "üî¥ ABANDONED"
                        
                        print(f"  Issue #{issue_num}: {issue['title'][:50]}...")
                        print(f"    Assigned: {hours_since_assigned:.1f}h ago, Has PR: {has_pr} ({status})")
                        
                        if is_abandoned:
                            abandoned_issues.append({
                                **issue,
                                'hours_abandoned': hours_since_assigned
                            })
                    
                    return abandoned_issues

            def _get_reissue_marker(self, issue_num: int) -> Optional[Dict]:
                """Return marker info if reissue was created: {new_issue, timestamp_iso} or None"""
                try:
                    comments = self.run_gh(
                        f'issue view {issue_num} --repo "{self.repo}" --json comments --jq ".comments[].body"'
                    )
                    if not comments:
                        return None
                    for line in comments.splitlines():
                        if line.startswith('reissue-created:'):
                            parts = line.split()
                            if len(parts) >= 4:
                                new_issue = int(parts[1])
                                ts = parts[3]
                                return { 'new_issue': new_issue, 'timestamp_iso': ts }
                    return None
                except Exception:
                    return None

            def _create_reissue(self, src_issue: Dict) -> Optional[int]:
                """Create a re-issue for activation attempt; return new issue number or None"""
                num = src_issue['number']
                title = src_issue.get('title', '')
                body = self.run_gh(
                    f'issue view {num} --repo "{self.repo}" --json body --jq .body'
                ) or ''
                new_title = f"Re-issue: {title} (activation attempt #1)"
                new_body = (
                    f"This is an automated re-issue for activation. Original: #{num}.\n\n" +
                    (body or '') +
                    "\n\n---\nAutomated by RFC Health Monitor"
                )
                print(f"Creating re-issue for #{num} -> '{new_title}'")
                self.run_gh(
                    f'issue create --repo "{self.repo}" --title "{new_title}" --body "{new_body}" --label game-rfc --assignee "Copilot"',
                    required=True
                )
                try:
                    new_num = self.run_gh(
                        f'issue list --repo "{self.repo}" --state open --search "{new_title}" --json number --jq ".[0].number"',
                        required=True
                    )
                    return int(new_num)
                except Exception:
                    return None

            def maybe_reissue_issue(self, issue: Dict) -> None:
                """If no PR for >2h, create a Re-issue, link and close original"""
                try:
                    num = issue['number']
                    hours = issue.get('hours_abandoned', 0)
                    if hours < 2 and not self.force_interventions:
                        return
                    marker = self._get_reissue_marker(num)
                    if marker:
                        return
                    prs_json = self.run_gh(
                        f'pr list --repo "{self.repo}" --search "Fixes #{num}" --json number'
                    )
                    has_pr = len(json.loads(prs_json) if prs_json else []) > 0
                    if has_pr and not self.force_interventions:
                        return
                    new_issue_num = self._create_reissue(issue)
                    if new_issue_num:
                        ts = datetime.datetime.now(datetime.timezone.utc).isoformat()
                        self.run_gh(
                            f'issue comment {num} --repo "{self.repo}" --body "reissue-created: {new_issue_num} at {ts}"'
                        )
                        self.run_gh(
                            f'issue comment {num} --repo "{self.repo}" --body "Closing in favor of re-issue #{new_issue_num}. @copilot please continue there."'
                        )
                        self.run_gh(
                            f'issue close {num} --repo "{self.repo}"'
                        )
                        print(f"? Created re-issue #{new_issue_num} and closed original #{num}")
                        self.interventions_taken.append(f"? Re-issued abandoned issue #{num} -> #{new_issue_num}")
                except Exception as e:
                    print(f"? Failed to create re-issue for #{issue.get('number')}: {e}")
                    
                except Exception as e:
                    print(f"Error checking issues: {e}")
                    return []
            
            def reactivate_stalled_pr(self, pr: Dict) -> None:
                """Post reactivation comment on stalled PR"""
                pr_num = pr['number']
                hours = pr['hours_stalled']
                
                comment = f"@copilot This PR appears to be stalled ({hours:.1f} hours without updates). Can you continue implementing the remaining requirements? Please focus on: completing any pending acceptance criteria from the RFC specification, running tests and fixing any failures, and moving from draft to ready for review when complete. Let me know if you need any clarification on the requirements. --- ü§ñ *Automated intervention from RFC Health Monitor*"
                
                try:
                      self.run_gh(f'pr comment {pr_num} --repo "{self.repo}" --body "{comment}"')
                    self.interventions_taken.append(f"üîÑ Reactivated stalled PR #{pr_num}")
                    print(f"‚úÖ Posted reactivation comment on PR #{pr_num}")
                except Exception as e:
                    print(f"‚ùå Failed to reactivate PR #{pr_num}: {e}")
            
            def reassign_abandoned_issue(self, issue: Dict) -> None:
                """Reassign abandoned issue to fresh GitHub Coding Agent"""
                issue_num = issue['number']
                hours = issue['hours_abandoned']
                
                try:
                    # Remove current assignment
                    self.run_gh(f'issue edit {issue_num} --repo "{self.repo}" --remove-assignee "Copilot"')
                    
                    # Wait a moment
                    import time
                    time.sleep(2)
                    
                    # Reassign to fresh instance
                    self.run_gh(f'issue edit {issue_num} --repo "{self.repo}" --add-assignee "Copilot"')
                    
                    # Post explanation comment
                    comment = f"Issue reassigned to fresh GitHub Coding Agent instance after {hours:.1f} hours without PR creation. The RFC specification is available in the linked documentation. Please create a feature branch and begin implementation. --- ü§ñ *Automated intervention from RFC Health Monitor*"
                    
                    self.run_gh(f'issue comment {issue_num} --repo "{self.repo}" --body "{comment}"')
                    self.interventions_taken.append(f"üîÑ Reassigned abandoned issue #{issue_num}")
                    print(f"‚úÖ Reassigned issue #{issue_num}")
                    
                except Exception as e:
                    print(f"‚ùå Failed to reassign issue #{issue_num}: {e}")
            
            def generate_health_report(self, stalled_prs: List, abandoned_issues: List) -> str:
                """Generate comprehensive health report"""
                timestamp = datetime.datetime.now(datetime.timezone.utc).strftime('%Y-%m-%d %H:%M:%S UTC')
                report = f"# üìä RFC Health Monitor Report\\n\\n**Timestamp**: {timestamp}\\n**Repository**: {self.repo}\\n\\n## üéØ Current Status\\n\\n### Pull Requests Status\\n"
                
                if stalled_prs:
                    report += f"- üî¥ **{len(stalled_prs)} stalled PR(s)** requiring intervention\n"
                    for pr in stalled_prs:
                        report += f"  - PR #{pr['number']}: {pr['hours_stalled']:.1f}h stalled\n"
                else:
                    report += "- üü¢ **All PRs active** - no stalled implementations detected\n"
                
                report += "\n### Issues Status\n"
                if abandoned_issues:
                    report += f"- üî¥ **{len(abandoned_issues)} abandoned issue(s)** requiring reassignment\n"
                    for issue in abandoned_issues:
                        report += f"  - Issue #{issue['number']}: {issue['hours_abandoned']:.1f}h without PR\n"
                else:
                    report += "- üü¢ **All issues active** - no abandoned assignments detected\n"
                
                report += f"\n## üîß Interventions Taken\n"
                if self.interventions_taken:
                    for intervention in self.interventions_taken:
                        report += f"- {intervention}\n"
                else:
                    report += "- ‚úÖ **No interventions needed** - system operating normally\n"
                
                report += f"\n## üìà Health Metrics\n"
                report += f"- **Monitoring Frequency**: Every 30 minutes during active hours\n"
                report += f"- **Stall Threshold**: 2 hours without PR updates\n"
                report += f"- **Abandonment Threshold**: 0.5 hours without PR creation\n"
                report += f"- **Automation Status**: {'üü¢ Operating' if not (stalled_prs or abandoned_issues) else 'üü° Intervening'}\n"
                
                return report
            
            def run(self) -> None:
                """Main monitoring execution"""
                print("üè• Starting RFC Health Monitor...")
                
                # Check for problems
                stalled_prs = self.check_stalled_prs()
                abandoned_issues = self.check_abandoned_issues()
                
                # Take interventions
                for pr in stalled_prs:
                    self.reactivate_stalled_pr(pr)
                
                for issue in abandoned_issues:
                    self.reassign_abandoned_issue(issue)
                    self.maybe_reissue_issue(issue)
                
                # Generate and display report
                report = self.generate_health_report(stalled_prs, abandoned_issues)
                print("\n" + "="*80)
                print(report)
                print("="*80)
                
                # Save report for potential commenting
                with open('/tmp/health_report.md', 'w') as f:
                    f.write(report)

        # Run the monitor
        monitor = RFCHealthMonitor()
        monitor.run()
        EOF
      env:
        # Use maintainer PAT for assignment operations within the monitor
        GH_TOKEN: ${{ secrets.COPILOT_ASSIGN_TOKEN }}
        
    - name: Post health report to coordinator issue
      if: always()
      run: |
        # Find RFC Coordinator issue
        COORDINATOR_ISSUE=$(gh issue list --label coordinator --json number --jq '.[0].number' || echo "")
        
        if [ -n "$COORDINATOR_ISSUE" ] && [ -f "/tmp/health_report.md" ]; then
          echo "üìä Posting health report to coordinator issue #$COORDINATOR_ISSUE"
          gh issue comment $COORDINATOR_ISSUE --repo "${{ github.repository }}" --body-file /tmp/health_report.md
        else
          echo "üìä Health report generated but no coordinator issue found"
        fi
      env:
        GH_TOKEN: ${{ steps.app-token.outputs.token }}

